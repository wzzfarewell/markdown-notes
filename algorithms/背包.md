# 背包问题

## 1. 01背包

问题要点：

1. 物品只能使用**一次**
2. 背包容量固定
3. 问背包所能装下的物品最大价值？

思路：

1. 二维dp数组

> dp[i][j] 表示从 [0,i] 的物品中随便取，放入容量为 j 的背包中的最大价值

```go
// 初始化
for j := w[0]; j < capacity; j++ {    // w: weight []int
    dp[0][j] = v[0]    // v: value []int
}
// 不放物品 i 时的 dp[i][j] = dp[i - 1][j]
// 放物品 i 时的 dp[i - 1][j - w[i]] + v[i]
// 二维数组中背包和物品的遍历顺序不重要，哪个在外面都可以
for i := 1; i < len(w); i++ {
    for j := 1; j < capacity; j++ {
        if j < w[i] {
            dp[i][j] = dp[i - 1][j]
        } else {
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])
        }
    }
}
```

2. 一维dp数组

> 一维数组，即一个滚动数组
> 
> dp[j] 表示容量为 j 的背包所能容纳的物品的最大价值

```go
// 初始化
dp := make([]int, 0)
// 递推
for i := 0; i < len(w); i++ {
    // 此处遍历背包容量时需要反序遍历，因为要保证物品只被放入背包一次
    for j := capacity; j >= w[i]; j-- {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i])
    }
}
```

## 2. 完全背包

问题要点：

1. 物品可以使用**无限次**

2. 背包容量固定

3. 问背包所能装下的物品最大价值？

思路：

> dp[j] 表示容量为 j 的背包所能容纳的物品的最大价值

```go
// 初始化为 0 即可
dp := make([]int, 0)
// 递推
// 对于完全背包来说，一维数组的背包和物品的遍历顺序不重要，哪个在外面都可以
for i := 0; i < len(w); i++ {
    // 此处遍历背包容量时需要正序遍历，因为物品可以放入背包无限次
    for j := w[i]; j <= capacity; j++ {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i])
    }
}
```

### 2.1 组合问题

> #### [零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
> 
> 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
> 
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
> 
> 假设每一种面额的硬币有无限个。 

求组合数的问题，递推公式一般为：`dp[j] += dp[j - goods[i]]`，且需要在外层遍历物品。

> dp[j] 表示可以凑成总金额为 j 的硬币组合数

```go
// 初始化为 1 ，不然后面的计算都没有意义
dp[0] = 1
// 递推
// 注意：组合问题需要在外层遍历物品
for i := 0; i < len(coins); i++ {
    for j := coins[i]; j <= amount; j++ {
        dp[j] += dp[j - coins[i]]
    }
}
```

### 2.2 排列问题

> [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
> 
> **进阶版**：
> 
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 
> 每次你可以爬 一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。你有多少种不同的方法可以爬到楼顶呢？
> 
> 注意：给定 n，m 是一个正整数。

思路：
1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。

问跳到楼顶有几种方法其实就是问装满背包有几种方法。

```go
// 初始化
dp[0] = 1
// 此处是排列问题，因为先跳2层再跳1层和先1层再2层是不同的方式
// 排列问题先遍历背包
for i := 1; i <= n; i++ {
    for j := 1; j <= m; j++ {
        if i < j {
            continue
        }
        dp[i] += dp[i - j]
    }
}
```


